[2024-11-21 09:23:09] ==================================  获取合约信息  ======================================
[2024-11-21 09:23:09] 	ContractName          : fact
[2024-11-21 09:23:09] 	ContractByteCodePath  : /data/wxj/transaction_rwset_fuzz/contract/contracts-go/fact/fact.7z
[2024-11-21 09:23:09] 	ContractFuncList      : save findByFileHash resetFact slowFind
[2024-11-21 09:23:09] 	ParamAndCandidateTypes:
map[file_hash:CandidateTypes{
		Len: 41,
		Types: map[[]byte:[0] []*reflect.rtype:[map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0]] []byte:[0] []byte:[0] []byte:[0] ():string (value any, ok bool):string (value any, ok bool):string (actual any, loaded bool):string (actual any, loaded bool, ok bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string ([]byte, error):string uint8:0 uint32:0 string:string unsafe.Pointer:string byte:0 bool:false int32:0 struct{typ *reflect.rtype; ptr unsafe.Pointer; reflect.flag}:map[flag:string ptr:string typ:map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0]] struct{bytes *byte}:map[bytes:0] struct{Status int32 "protobuf:\"varint,1,opt,name=status,proto3\" json:\"status,omitempty\""; Message string "protobuf:\"bytes,2,opt,name=message,proto3\" json:\"message,omitempty\""; Payload []byte "protobuf:\"bytes,3,opt,name=payload,proto3\" json:\"payload,omitempty\""}:map[Message:string Payload:[0] Status:0] struct{list []encoding/json.field; nameIndex map[string]int}:map[list:[map[encoder:string equalFold:string index:[0] name:string nameBytes:[0] nameEscHTML:string nameNonEsc:string omitEmpty:false quoted:false tag:false typ:string]] nameIndex:string] func(e *encoding/json.encodeState, v reflect.Value, opts encoding/json.encOpts):string interface{}:string any:string interface{Error() string}:string interface{Align() int; AssignableTo(u reflect.Type) bool; Bits() int; ChanDir() reflect.ChanDir; Comparable() bool; ConvertibleTo(u reflect.Type) bool; Elem() reflect.Type; Field(i int) reflect.StructField; FieldAlign() int; FieldByIndex(index []int) reflect.StructField; FieldByName(name string) (reflect.StructField, bool); FieldByNameFunc(match func(string) bool) (reflect.StructField, bool); Implements(u reflect.Type) bool; In(i int) reflect.Type; IsVariadic() bool; Key() reflect.Type; Kind() reflect.Kind; Len() int; Method(int) reflect.Method; MethodByName(string) (reflect.Method, bool); Name() string; NumField() int; NumIn() int; NumMethod() int; NumOut() int; Out(i int) reflect.Type; PkgPath() string; Size() uintptr; String() string; common() *reflect.rtype; uncommon() *reflect.uncommonType}:string sync.entry:map[p:string] reflect.rtype:map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0] reflect.tflag:0 reflect.nameOff:0 reflect.typeOff:0 reflect.ptrType:map[elem:map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0] rtype:map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0]] fact.Fact:map[FileHash:string FileName:string Time:0]],
		Confirm: false,
		ConfirmValue: [],
	} file_name:CandidateTypes{
		Len: 41,
		Types: map[[]byte:[0] []*reflect.rtype:[map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0]] []byte:[0] []byte:[0] []byte:[0] ():string (value any, ok bool):string (value any, ok bool):string (actual any, loaded bool):string (actual any, loaded bool, ok bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string ([]byte, error):string uint8:0 uint32:0 string:string unsafe.Pointer:string byte:0 bool:false int32:0 struct{typ *reflect.rtype; ptr unsafe.Pointer; reflect.flag}:map[flag:string ptr:string typ:map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0]] struct{bytes *byte}:map[bytes:0] struct{Status int32 "protobuf:\"varint,1,opt,name=status,proto3\" json:\"status,omitempty\""; Message string "protobuf:\"bytes,2,opt,name=message,proto3\" json:\"message,omitempty\""; Payload []byte "protobuf:\"bytes,3,opt,name=payload,proto3\" json:\"payload,omitempty\""}:map[Message:string Payload:[0] Status:0] struct{list []encoding/json.field; nameIndex map[string]int}:map[list:[map[encoder:string equalFold:string index:[0] name:string nameBytes:[0] nameEscHTML:string nameNonEsc:string omitEmpty:false quoted:false tag:false typ:string]] nameIndex:string] func(e *encoding/json.encodeState, v reflect.Value, opts encoding/json.encOpts):string interface{}:string any:string interface{Error() string}:string interface{Align() int; AssignableTo(u reflect.Type) bool; Bits() int; ChanDir() reflect.ChanDir; Comparable() bool; ConvertibleTo(u reflect.Type) bool; Elem() reflect.Type; Field(i int) reflect.StructField; FieldAlign() int; FieldByIndex(index []int) reflect.StructField; FieldByName(name string) (reflect.StructField, bool); FieldByNameFunc(match func(string) bool) (reflect.StructField, bool); Implements(u reflect.Type) bool; In(i int) reflect.Type; IsVariadic() bool; Key() reflect.Type; Kind() reflect.Kind; Len() int; Method(int) reflect.Method; MethodByName(string) (reflect.Method, bool); Name() string; NumField() int; NumIn() int; NumMethod() int; NumOut() int; Out(i int) reflect.Type; PkgPath() string; Size() uintptr; String() string; common() *reflect.rtype; uncommon() *reflect.uncommonType}:string sync.entry:map[p:string] reflect.rtype:map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0] reflect.tflag:0 reflect.nameOff:0 reflect.typeOff:0 reflect.ptrType:map[elem:map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0] rtype:map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0]] fact.Fact:map[FileHash:string FileName:string Time:0]],
		Confirm: false,
		ConfirmValue: [],
	} time:CandidateTypes{
		Len: 48,
		Types: map[[]byte:[0] []byte:[0] []*reflect.rtype:[map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0]] []byte:[0] []byte:[0] []byte:[0] ():string (value any, ok bool):string (value any, ok bool):string (actual any, loaded bool):string (actual any, loaded bool, ok bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string (*sync.entry, bool):string (uint64, error):string (i int64, err error):string ([]byte, error):string uint8:0 uint32:0 uint64:0 string:string unsafe.Pointer:string byte:0 bool:false int32:0 int64:0 struct{typ *reflect.rtype; ptr unsafe.Pointer; reflect.flag}:map[flag:string ptr:string typ:map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0]] struct{bytes *byte}:map[bytes:0] struct{Status int32 "protobuf:\"varint,1,opt,name=status,proto3\" json:\"status,omitempty\""; Message string "protobuf:\"bytes,2,opt,name=message,proto3\" json:\"message,omitempty\""; Payload []byte "protobuf:\"bytes,3,opt,name=payload,proto3\" json:\"payload,omitempty\""}:map[Message:string Payload:[0] Status:0] struct{list []encoding/json.field; nameIndex map[string]int}:map[list:[map[encoder:string equalFold:string index:[0] name:string nameBytes:[0] nameEscHTML:string nameNonEsc:string omitEmpty:false quoted:false tag:false typ:string]] nameIndex:string] func(e *encoding/json.encodeState, v reflect.Value, opts encoding/json.encOpts):string interface{}:string any:string interface{Error() string}:string interface{Align() int; AssignableTo(u reflect.Type) bool; Bits() int; ChanDir() reflect.ChanDir; Comparable() bool; ConvertibleTo(u reflect.Type) bool; Elem() reflect.Type; Field(i int) reflect.StructField; FieldAlign() int; FieldByIndex(index []int) reflect.StructField; FieldByName(name string) (reflect.StructField, bool); FieldByNameFunc(match func(string) bool) (reflect.StructField, bool); Implements(u reflect.Type) bool; In(i int) reflect.Type; IsVariadic() bool; Key() reflect.Type; Kind() reflect.Kind; Len() int; Method(int) reflect.Method; MethodByName(string) (reflect.Method, bool); Name() string; NumField() int; NumIn() int; NumMethod() int; NumOut() int; Out(i int) reflect.Type; PkgPath() string; Size() uintptr; String() string; common() *reflect.rtype; uncommon() *reflect.uncommonType}:string error:string sync.entry:map[p:string] strconv.NumError:map[Err:string Func:string Num:string] reflect.rtype:map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0] reflect.tflag:0 reflect.nameOff:0 reflect.typeOff:0 reflect.ptrType:map[elem:map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0] rtype:map[align:0 equal:string fieldAlign:0 gcdata:0 hash:0 kind:0 ptrToThis:0 ptrdata:string size:string str:0 tflag:0]] fact.Fact:map[FileHash:string FileName:string Time:0]],
		Confirm: false,
		ConfirmValue: [],
	}]
[2024-11-21 09:23:09] =======================================================================================
[2024-11-21 09:23:26] ====================================  部署合约  ========================================
[2024-11-21 09:23:34] Claim Txid: 180a01d1b634b830ca659bf68ade7d10b82342240a144935899cd9136a5a8729
[2024-11-21 09:23:34] result code:0, msg:SUCCESS

[2024-11-21 09:23:34] =======================================================================================
[2024-11-21 09:23:34] =============================  冲突交易集测试/交易对变异  ===============================
[2024-11-21 09:23:34] =======================================================================================
[2024-11-21 09:23:34] round:[0] 使用冲突交易对种子进行测试
[2024-11-21 09:30:59] round:[0] 冲突交易对种子测试结束！
[2024-11-21 09:30:59] round:[0] 使用冲突交易对种子进行测试
